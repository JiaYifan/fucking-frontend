在本地开发时使用原生的 ES Module 特性导入你的代码。在生产环境使用 Rollup 打包代码。

在本地，vite 只启动一台静态页面的服务器，对文件代码不打包，服务器会根据客户端的请求加载不同的模块处理，实现真正的按需加载。

对于热更新问题，vite 采用立即编译当前修改文件的办法。同时 vite 还会使用缓存机制( http 缓存 => vite 内置缓存 )，加载更新后的文件内容。

所以，vite 具有了快速冷启动、按需编译、模块热更新等优良特质。

## 模块路径重写

原生的 ES module 不支持裸模块的导入，所以 Vite 进行了模块加载路径的重写

## 预优化

Vite 0.15 现在启动时会自动分析依赖进行一次预优化，把没有提供 esm 格式的依赖和内部有大量模块的依赖提前打包，减少开发时 es import 的请求数量，解决 es import 在开发中的主要软肋（请求多了影响页面 reload 速度）。这一步后会对保存一个当前依赖和配置的 hash，确保只有依赖变动的时候才需要重新优化。另外实验性的加入了 vite —sw 选项，用 service worker 缓存编译过的文件，进一步减少请求瓶颈。这两个优化稳定时候，我觉得 vite 可以胜任大型项目了。

## 热替换-避免页面状态丢失

热替换(Hot Module Replacement) 指的是修改代码后无需刷新页面即可生效。经常跟 Hot Module Reload 搞混。一个成熟的框架是必须要具备热替换能力的。Vite 的热替换实现与业界知名的一些模块如 webpack-dev-server 的实现类似。本质都是通过 websocket 建立服务端与浏览器的通信。

虽然 webpack 提供了  webpack --watch  的命令来   动态监听文件的改变并实时打包，输出新 bundle.js 文件，这样文件多了之后打包速度会很慢，此外这样的打包的方式不能做到 hot replace，即每次 webpack 编译之后，你还需要手动刷新浏览器。

webpack-dev-server 其中部分功能就能克服上面的 2 个问题。webpack-dev-server 主要是启动了一个使用 express 的 Http 服务器。它的作用主要是用来伺服资源文件。此外这个 Http 服务器和 client 使用了 websocket 通讯协议，原始文件作出改动后，webpack-dev-server 会实时的编译，但是最后的编译的文件并没有输出到目标文件夹，而是为了加快打包进程是将打包后的文件放到内存中的，所以要想获取新的 dist 文件用于部署项目需要单独用 webpack 打包。

> [热更新与热替换](https://blog.csdn.net/ganle/article/details/106455612)

Q1：可能你会问，为什么我们开启 HMR 过后，样式文件的修改就可以直接热更新呢？我们好像也没有手动处理样式模块的更新啊？

A1：这是因为样式文件是经过 Loader 处理的，在 style-loader 中就已经自动处理了样式文件的热更新，所以就不需要我们额外手动去处理了。

Q2：那你可能会想，凭什么样式就可以自动处理，而我们的脚本就需要自己手动处理呢？

A2：这个原因也很简单，因为样式模块更新过后，只需要把更新后的 CSS 及时替换到页面中，它就可以覆盖掉之前的样式，从而实现更新。

而我们所编写的 JavaScript 模块是没有任何规律的，你可能导出的是一个对象，也可能导出的是一个字符串，还可能导出的是一个函数，使用时也各不相同。所以 Webpack 面对这些毫无规律的 JS 模块，根本不知道该怎么处理更新后的模块，也就无法直接实现一个可以通用所有情况的模块替换方案。

那这就是为什么样式文件可以直接热更新，而 JS 文件更新后页面还是回退到自动刷新的原因。

Q3：那可能还有一些平时使用 vue-cli 或者 create-react-app 这种框架脚手架工具的人会说，“我的项目就没有手动处理，JavaScript 代码照样可以热替换，也没你说的那么麻烦”。

A3：这是因为你使用的是框架，使用框架开发时，我们项目中的每个文件就有了规律，例如 React 中要求每个模块导出的必须是一个函数或者类，那这样就可以有通用的替换办法，所以这些工具内部都已经帮你实现了通用的替换操作，自然就不需要手动处理了。
